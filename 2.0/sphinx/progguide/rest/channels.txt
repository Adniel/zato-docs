.. highlight:: python
   :linenothreshold: 0

REST channels
=============

:doc:`Plain HTTP channels <../../web-admin/channels/plain-http>` offer several interesting points that facilitate
the development of REST channels, including the most popular ones using JSON.

* URL paths can include patterns
* URL parameters can form part of the input to a service
* Users can decide which parameter types take precedence over one another
* Access to a channel can be limited to a selected HTTP verb only
* Data format can be set to JSON
* Services can react to user-chosen HTTP verbs only (documented in :doc:`a separate chapter <services>`)

Note that in order to take advantage of URL path patterns and URL parameters a service needs to use
:doc:`SimpleIO <../sio>`, such as the one below which will be used throughout the chapter.

::

    # -*- coding: utf-8 -*-
    
    from __future__ import absolute_import, division, print_function, unicode_literals
    
    from zato.server.service import Service
    
    class GetBalance(Service):
    
        class SimpleIO:
            input_required = ('cust_no', 'account_no')
            output_required = ('balance', 'currency')
    
        def handle(self):

            # Confirm input was received
            self.logger.info('Customer: %s', self.request.input.cust_no)
            self.logger.info('Account: %s', self.request.input.account_no)

            # Produce sample output
            self.response.payload.balance = '357.19'
            self.response.payload.currency = 'EUR'


Clean URLs with path patterns
-----------------------------

A sample clean URL may read http://localhost:11223/customer/balance/37172/HAZDM017/ and to configure it from the web admin
one would fill out a form to create a :doc:`plain HTTP channels <../../web-admin/channels/plain-http>` as follows.
Note that the URL path contains parameters enclosed between *{* and *}* and *Merge URL params to req* is on.

.. image:: /gfx/progguide/rest/clean-urls.png
   :width: 95%

Now the service can be invoked using a nice and clean URL:

::

    $ curl http://localhost:11223/customer/balance/37172/HAZDM017/ ; echo
    {"response": {"currency": "EUR", "balance": "357.19"}}
    $ 

And the contents of server.log confirms that the input was received fine:

::

    INFO - Customer: 37172
    INFO - Account: HAZDM017

Parameters in query path
------------------------

The same service can be mounted on another channel that will let client applications use query parameters rather than ones
embedded in a path.

.. image:: /gfx/progguide/rest/query-params.png
   :width: 95%

::

    $ curl "http://localhost:11223/customer/balance?cust_no=198271&account_no=KMZQ62M" ; echo
    {"response": {"currency": "EUR", "balance": "357.19"}}
    $

Again, server.log confirms the input was the same:

::

    INFO - Customer: 198271
    INFO - Account: KMZQ62M

Using JSON payload
------------------

Note that it's always possible to invoke the very same service by using JSON payload on input:

::

    $ curl http://localhost:11223/customer/balance -d \
        '{"cust_no":"38631", "account_no":"JZM92KH"}' ; echo
    {"response": {"currency": "EUR", "balance": "357.19"}}
    $

::

    INFO - Customer: 38631
    INFO - Account: JZM92KH
